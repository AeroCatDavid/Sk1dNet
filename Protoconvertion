#include "gui.h"
#include "VMProtectSDK.h"
#include "memscan.h"
#include <Shlwapi.h>
static bool scan_finished = false;

#define R_PROTO_OBFUSCATE(p, v) *(int*)(int)(p) = (int)(v) + (int)(p)
#define RL_CLOSURE_OBFUSCATE(p, v) *(int*)(int)(p) = (int)(v) - (int)(p)

namespace lua_to_roblox
{
	VOID convert_proto(int rl, Proto* p, r_proto* rp, int* rpnups) { // same order as readProto
																	 /* main conversion of vanilla proto to roblox proto */

		R_PROTO_OBFUSCATE(&rp->source, RLUAS_NEW(rl, getstr(p->source)));

		rp->sizep = p->sizep;
		auto** rpp_mem = (r_proto**)RLUAM_MALLOC(rl, sizeof(r_proto**) * p->sizep);
		R_PROTO_OBFUSCATE(&rp->p, rpp_mem);

		for (int k = 0; k < p->sizep; k++) {
			rpp_mem[k] = rluaF_newproto(rl);
			convert_proto(rl, p->p[k], rpp_mem[k], rpnups);
		}

		rp->sizek = p->sizek;
		auto* rp_k_mem = (r_tvalue*)RLUAM_MALLOC(rl, sizeof(r_tvalue) * p->sizek);
		R_PROTO_OBFUSCATE(&rp->k, rp_k_mem);

		for (int k = 0; k < p->sizek; k++) {
			TValue* o = &p->k[k];
			r_tvalue* ro = &rp_k_mem[k];
			switch (o->tt) {
			case LUA_TNIL:
				ro->tt = RLUA_TNIL;
				ro->value.n = 0;
				break;
			case LUA_TBOOLEAN:
				ro->tt = RLUA_TBOOLEAN;
				ro->value.b = o->value.b;
				break;
			case LUA_TNUMBER:
				ro->tt = RLUA_TNUMBER;
				ro->value.n = r_xor_number(&o->value.n);
				break;
			case LUA_TSTRING:
				ro->tt = RLUA_TSTRING;
				ro->value.gc = RLUAS_NEW(rl, getstr((TString*)o->value.gc));
				break;
			default:
				break;
			}
		}

		rp->sizecode = p->sizecode;
		auto* rp_code_mem = (int*)RLUAM_MALLOC(rl, sizeof(int*) * p->sizecode);
		R_PROTO_OBFUSCATE(&rp->code, rp_code_mem);

		for (int k = 0; k < p->sizecode; k++) {
			/* instruction conversion */

			Instruction inst = p->code[k]; //vanilla instruction
			int r_inst = 0;
			OpCode op = GET_OPCODE(inst);

			RSET_OPCODE(r_inst, get_roblox_opcode[op]);

			switch (getOpMode(op)) {
			case iABC:
				RSETARG_A(r_inst, GETARG_A(inst));
				RSETARG_B(r_inst, GETARG_B(inst));
				RSETARG_C(r_inst, GETARG_C(inst));
				break;
			case iABx:
				RSETARG_A(r_inst, GETARG_A(inst));
				RSETARG_Bx(r_inst, GETARG_Bx(inst));
				break;
			case iAsBx:
				RSETARG_A(r_inst, GETARG_A(inst));
				RSETARG_sBx(r_inst, GETARG_sBx(inst));
				break;
			}

			switch (op) {
			case OP_JMP:
				r_inst = r_inst >> 26 << 26 | jump_encryption(r_inst, k);
				break;
			case OP_CALL:
				r_inst = r_inst >> 26 << 26 | call_enc(r_inst, k);
				break;
			case OP_TAILCALL:
			case OP_RETURN:
				r_inst = r_inst >> 26 << 26 | dax_encode_op(r_inst, k, 1470882913, k - 1577854801, 641680189) & 0x3FFFFFF;
				break;
			case OP_CLOSURE:
				r_inst = r_inst >> 26 << 26 | closure_enc(r_inst, k);
				break;
			case OP_SETUPVAL:
				r_inst = r_inst >> 26 << 26 | setupval_encryption(r_inst, k);
			case OP_MOVE:
				r_inst = r_inst & 0xFFFC21FF | 0x2000;
				break;
			}

			rp_code_mem[k] = r_inst * encode_key;
		}

		// sizelocvars set
		rp->sizelineinfo = p->sizelineinfo;
		auto* rp_lineinfo_mem = (int*)RLUAM_MALLOC(rl, sizeof(int*) * p->sizelineinfo);
		R_PROTO_OBFUSCATE(&rp->lineinfo, rp_lineinfo_mem);

		for (int k = 0; k < p->sizelineinfo; k++) {
			rp_lineinfo_mem[k] = p->lineinfo[k] ^ (k << 8);
		}

		// sizeupvalues set
		rp->maxstacksize = p->maxstacksize;
		rp->is_vararg = p->is_vararg;
		*rpnups += p->nups; rp->nups = p->nups;
		rp->numparams = p->numparams;
	}

	VOID set_l_closure(int rl, LClosure* lcl) {
		Proto* p = lcl->p;
		r_proto* rp = rluaF_newproto(rl);
		int rpnups = 0;

		convert_proto(rl, p, rp, &rpnups);
		rl_closure* rlcl = rluaF_newLclosure(rl, rpnups, *(int*)(rl + RL_L_GT));
		RL_CLOSURE_OBFUSCATE(&rlcl->p, rp);

		for (int k = 0; k < rpnups; k++) {
			*(int*)((int)&rlcl->upvals[k]) = rluaF_newupval(rl);
		}

		rlua_pushlclosure(rl, rlcl);
	}

	VOID call_l_closure(int rl, LClosure* lcl) {
		set_l_closure(rl, lcl);
		r_spawn(rl);
	}

	VOID execute_script(int rl, lua_State* l, std::string source) {
		int r_thread = r_lua_newthread(rl);
		set_encode_key(r_thread, &encode_key);
		set_localscript(rl);

		int unk[] = { NULL, NULL };
		r_sandbox_thread(r_thread, 6, (int)unk);

		if (luaL_loadstring(l, source.c_str())) {
			printf("Error: %s\n", lua_tostring(l, -1));
			lua_pop(l, 1);
		}

		else {
			util::pause();
			TValue* o = (l->top) - 1;
			LClosure* lcl = &clvalue(o)->l;
			call_l_closure(r_thread, lcl);
			lua_pop(l, 1);
			util::resume();
		}

		printf("\nlstack: %d\n", lua_gettop(l));
		printf("rstack: %d\n", RLUA_GETTOP(rl));
	}
}

/* 
   [*] This is the execute part. So when you want to execute something just do: execute_script("print('Proto-works!')")
*/

void execute_script(int rL, lua_State* L, const std::string &source) {
	lua_to_roblox::execute_script(rL, L, source);
}

/* Extra bc we need */

#pragma once
#include <Windows.h>

#include "rlua.h"
#include "encrypt.h"
#include "util.h"

extern "C" {
	// lua core
#include "Lua\lua.h"
#include "Lua\lauxlib.h"
#include "Lua\lualib.h"
	// lua internals
#include "Lua\lobject.h"
#include "Lua\lstate.h"
#include "Lua\lfunc.h"
#include "Lua\lopcodes.h"
	// lparser.c modified for roblox's op_closure change
}

static lua_State* L; //this is initialized in the main() function, located in the main.cpp file
static bool parented_script = false; //used to indicate whether the script should be parented to the localplayers backpack or not
static bool debug_mode = false;
static DWORD script;

/* instruction format */
#define R_POS_OP				26
#define R_POS_A					18
#define R_POS_B					0
#define R_POS_C					9
#define R_POS_Bx				R_POS_B

#define R_SET_OPCODE(i,o) ((i) = (((i)&MASK0(SIZE_OP,R_POS_OP)) | ((cast(Instruction, o)<<R_POS_OP)&MASK1(SIZE_OP,R_POS_OP))))
#define R_SETARG_A(i,u)   ((i) = (((i)&MASK0(SIZE_A,R_POS_A)) | ((cast(Instruction, u)<<R_POS_A)&MASK1(SIZE_A,R_POS_A))))
#define R_SETARG_B(i,b)   ((i) = (((i)&MASK0(SIZE_B,R_POS_B)) | ((cast(Instruction, b)<<R_POS_B)&MASK1(SIZE_B,R_POS_B))))
#define R_SETARG_C(i,b)   ((i) = (((i)&MASK0(SIZE_C,R_POS_C)) | ((cast(Instruction, b)<<R_POS_C)&MASK1(SIZE_C,R_POS_C))))
#define R_SETARG_Bx(i,b)  ((i) = (((i)&MASK0(SIZE_Bx,R_POS_Bx)) | ((cast(Instruction, b)<<R_POS_Bx)&MASK1(SIZE_Bx,R_POS_Bx))))
#define R_SETARG_sBx(i,b) R_SETARG_Bx((i),cast(Instruction, (b)+MAXARG_sBx))

#define RSET_OPCODE(i,o)	((i) = (((i) & MASK0(6, 26)) | (((Instruction)o << 26) & MASK1(6, 26))))
#define RGET_OPCODE(i)		(i >> 26 & MASK1(6, 0))

#define RSETARG_A(i,o)		((i) = (((i) & MASK0(8, 18)) | (((Instruction)o << 18) & MASK1(8, 18))))
#define RGETARG_A(i)		(i >> 18 & MASK1(8, 0))

#define RSETARG_B(i,o)		((i) = (((i) & MASK0(9, 0)) | (((Instruction)o << 0) & MASK1(9, 0))))
#define RGETARG_B(i)		(i >>  0 & MASK1(9, 0))

#define RSETARG_C(i,o)		((i) = (((i) & MASK0(9, 9)) | (((Instruction)o << 9) & MASK1(9, 9))))
#define RGETARG_C(i)		(i >>  9 & MASK1(9, 0))

#define RSETARG_Bx(i,b)		((i) = (((i) & MASK0(18, 0)) | (((Instruction)b << 0) & MASK1(18, 0))))
#define RGETARG_Bx(i)		(i >>  0 & MASK1(18, 0))

#define RSETARG_sBx(i,b)	RSETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
#define RGETARG_sBx(i)		(RGETARG_Bx(i)-MAXARG_sBx)

const char get_roblox_opcode[NUM_OPCODES]{ // modified instruction set enum
	6, // OP_MOVE
	4, // OP_LOADK
	0, // OP_LOADBOOL
	7, // OP_LOADNIL
	2, // OP_GETUPVAL
	8, // OP_GETGLOBAL
	1, // OP_GETTABLE
	3, // OP_SETGLOBAL
	5, // OP_SETUPVAL
	15, // OP_SETTABLE
	13, // OP_NEWTABLE
	9, // OP_SELF
	16, // OP_ADD
	11, // OP_SUB
	17, // OP_MUL
	10, // OP_DIV
	11, // OP_MOD
	14, // OP_POW
	24, // OP_UNM
	22, // OP_NOT
	18, // OP_LEN
	25, // OP_CONCAT
	20, // OP_JMP
	26, // OP_EQ
	19, // OP_LT
	21, // OP_LE
	23, // OP_TEST
	33, // OP_TESTSET
	31, // OP_CALL
	27, // OP_TAILCALL
	34, // OP_RETURN
	29, // OP_FORLOOP
	35, // OP_FORPREP
	28, // OP_TFORLOOP
	30, // OP_SETLIST
	32, // OP_CLOSE
	37, // OP_CLOSURE
	36, // OP_VARARG
};

namespace lua_to_roblox {
	VOID convert_proto(int rl, Proto* p, r_proto* rp, int* rpnups);
	VOID set_l_closure(int rl, LClosure* lcl);
	VOID call_l_closure(int rl, LClosure* lcl);
	VOID execute_script(int rl, lua_State* l, std::string source);
}

VOID execute_script(int rL, lua_State* L, const std::string &source);
